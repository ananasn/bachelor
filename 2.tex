 \def\figureautorefname{рис.}
\chapter{Модули реализуемого программного комплекса}
\section{Модуль 3D-моделирования рельефа}
\subsection{Назначение модуля}

Построение 3D-модели рельефа важно по двум причинам:
\begin{itemize}
\item 3D-модель рельефа позволяет визуализировать будущий результат.
\item 3D-модель является входными данными для множества CAM-систем.
\end{itemize}

Данный модуль реализует обе эти функции\,(\autoref{fig:seq_diagram}). После загрузки изображения в специальное поле в приложении и отправки его на сервер происходит обработка изображения, в результате которой 3D-модель записивается в файл. Затем, 3D-модель может быть отображена в браузере с помощью библиотеки Three.js. Также приложение предоставляет возможность скачивания модели. Такая функциональность может оказаться полезной, например, когда пользователь хочет получить УП не в G-кодах, а в другой нотации (например, RML-код для оборудования фирмы Roland).

\begin{figure}[h!]
    \centering
    \includegraphics[width=1.15\textwidth]{seq_diagram.png}
    \caption[Функционирование модуля 3D-моделирования.]
            {Функционирование модуля 3D-моделирования.}
    \label{fig:seq_diagram}
\end{figure} 
\subsection{Принципы построения модели}

После загрузки на сервер изображение подвергается обработке. В гравировке вся цветовая информация преобразуется в рельеф с впадинами разной глубины. Для того, чтобы корректно перенести цветное изображение на изделие, его преобразуют в градации серого. Это производится с помощью библиотеки Python Image Library\cite{Python_multimedia}, которая позволяет оперировать пикселями изображения. Цветное растровое изображение состоит из пикселей, каждый из которых характеризуется тремя величинами, определяющими содержание красного, синего и зеленого цветов. Известно, что оттенки серого получаются в результате одинакового содержания этих цветов в пикселе. Таким образом, преобразование в градации серого осуществляется по следующей схеме:
\begin{equation}\label{e:grey}
  H = \frac{(R+G+B)}{3}, для  \forall p: \exists p = (R, G, B) 
\end{equation}
Результирующая величина $H$ будет лежать в промежутке от 0 до 255, поэтому необходимо провести нормирование, в результате которого величина переносится в промежуток от 0 до 3. Затем, с шагом $\Delta x$ и $\Delta y$ генерируются вершины треугольных граней будущей модели рельефа. В результате работы модуля данные о модели записываются в файл в соответствии с форматом.
\subsection{Выбор формата}
 Существует множество форматов для хранения 3D-моделей, однако далеко не все из них пригодны для хранения рельефов и отображения их в веб-приложении.
 
 Можно определить два основных критерия, по которым стоит отбирать формат для разрабатываемого приложения:
 \begin{itemize}
 \item поддерживаемость библиотекой Three.js;
 \item размер файла с моделью.
 \end{itemize}
 
 Three.js поддерживает довольно широкий перечень традиционных форматов: STL ASCII, Binary STL, VRML и т.д.
 Также Three.js предлагает возможность хранения 3D-моделей в JSON формате. Изначально, был выбран формат JSON\,(\autoref{fig:json_view}), так как организация данных в нем наиболее проста и и интуитивно понятна, а сам формат изначально предназначен для представления данных в веб-приложениях. Однако после реализации стало очевидно,что для высокополигональных моделей рельефов такой формат не подходит. Основной проблемой оказался размер файла, который был слишком большим. А это в свою очередь сильно замедляло работу приложения.
 \begin{figure}[h!]
    \centering
    \includegraphics[width=.8\textwidth]{json.png}
    \caption[Представление модели в формате JSON.]
            {Представление модели в формате JSON.}
    \label{fig:json_view}
\end{figure} 

Самым оптимальным форматом оказался Binary STL\,(\autoref{fig:stl}), так как бинарный формат позволял максимально сжать размер 3D-модели рельефа.

 \begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{STL.png}
    \caption[Представление модели в формате Binary STL.]
            {Представление модели в формате Binary STL.}
    \label{fig:stl}
\end{figure} 
Для сравнения форматов приведена диаграмма\,(\autoref{fig:format_diagram}), которая демонстрирует, насколько сокращается время загрузки модели при использовании Binary STL.
Диаграмма построена на основе данных, полученных при следующих характеристиках системы:
\begin{itemize}
\item  виртуальная машина Cloud9;
\item 512\,Mb RAM;
\item 1\,GB hard drive;
\item канал 10\,Мбит/c;
\item изображение 180x256.
\end{itemize}
 \begin{figure}[h!]
    \centering
    \includegraphics[width=.8\textwidth]{format_diagram.png}
    \caption[Сравнение JSON и Binary STL.]
            {Сравнение JSON и Binary STL.}
    \label{fig:format_diagram}
\end{figure} 
\section{Модуль редактирования изображений}
\subsection{Назначение}
Очевидно, что  в некоторых случаях результат, визуализированный с помощью 3D-модели, может по определенным причинам не удовлетворить пользователя. И для того, чтобы получить подходящий результат, необходимо отредактировать входные данные, в качестве которых в разрабатываемом приложении выступает изображение.

Чаще всего причинами неудовлетворительного результата служат:
\begin{itemize}
\item низкое качество изображения;
\item слишком светлое изображение;
\item излишние детали изображения.
\end{itemize}
Все эти проблемы можно решить минимумом инструментов, а именно -- настройками яркости и контрастности. Наиболее распространенная проблема для растровых изображений -- это низкое качество. Из-за пиксельности изображения по контурам могут возникаит деформации. Однако настройки контрастности и яркости позволяют избежать нежелательных деформаций\,(\autoref{fig:demonstration}).
 \begin{figure}[h!]
    \centering
    \includegraphics[width=.8\textwidth]{demonstration.png}
    \caption[Упразднение деформаций в моделях на основе растровых изображений.]
            {Упразднение деформаций в моделях на основе растровых изображений.}
    \label{fig:demonstration}
\end{figure} 
\subsection{Алгоритм изменения яркости}
Для регулировки яркости к каждому каналу каждого пикселя прибавляется определенное значение. Если оно положительное яркость увеличивается, если отрицательное яркость уменьшается\,(\autoref{fig:brightness}). 
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.73\textwidth]{Brightness.png}
    \caption[Алгоритм изменения яркости.]
            {Алгоритм изменения яркости.}
    \label{fig:brightness}
\end{figure} 
\subsection{Алгоритм изменения контраста}
Для регулировки контраста вначале вычисляется средняя яркость изображения. Для этого вначале вычисляется яркость каждого пикселя. Затем, для каждого пикселя находится отклонение от средней яркости. После чего это отклонение умножается на коэффициент контраста. Полученная величина прибавляется к значению каждого канала\,(\autoref{fig:contrast}).
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{Contrast.png}
    \caption[Алгоритм изменения контраста]
            {Алгоритм изменения контраста.}
    \label{fig:contrast}
\end{figure} 
\section{Модуль генерации управляющих программ}
\subsection{Назначение модуля}
Модуль генерации управляющих программ предназначен для получения последовательности G-кодов. G-код включает в себя команды управления перемещением инструмента и рабочих органов оборудования, команды определяющие режимы обработки, технологические команды, команды выбора системы координат и едениц измерений\cite{theory_of_cnc}. Большинство программного обеспечения, управляющего оборудованием, использует в качестве управляющих программ последовательности G-кодов. Стоит отметить, что сам G-код, определяемый стандартами ISO 6983-1:1982 и ГОСТ 20999-83, может расширяться в зависимости от назначения и производителей оборудования. Фактически, G-код является некоторой основой для реального языка программирования устройств с ЧПУ. Однако использование базовых команд обеспечивает высокую вероятность корректной работы на большинстве оборудования.

С точки зрения реализации, растровое изображение проще всего наносить точечно. Тем более, что при таком подходе понадобятся только стандартные G-коды. Таким образом, на основе данных, полученных на этапе обработки изображения и построения модели, генерируется управляющая программа, которая в дальнейшем становится доступной для скачивния с сервера\,(\autoref{fig:g_module}).
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.4\textwidth]{g_module.png}
    \caption[Функционирование модуля генерации управляющих программ.]
            {Функционирование модуля генерации управляющих программ.}
    \label{fig:g_module}
\end{figure} 
\subsection{Реализация модуля}
Генератор управляющих программ представляет собой модуль\,(\autoref{app:gcodes}), который хранится на сервере. Внутри данного модуля реализован класс Generator, который инициализируется следующими значениями:
\begin{itemize}
\item карта высот, которая генерируется на сервере при обработке изображения;
\item высота изображения в пикселях;
\item ширина изображения в пикселях;
\item величина смещения по осям;
\item величина нормирования;
\item хэш по имени изображения\,(рассчитывается по алгоритму Роберта Седжвика при загрузке на сервер).
\end{itemize}

Также при инициализации данного класса создаются основные блоки, из которых при генерации будет складываться УП:
\begin{itemize}
\item преамбула;
\item блоки тела УП;
\item концевик.
\end{itemize}

{\bfseries Преамбула.} Преамбула представляет из себя неизменяемый блок. Она включает в себя символ начала программы, имя программы, команды смены системы координат и единиц измерений, команды холостого хода,команду начала вращения шпинделя, команды установки скорости вращения шпинделя и скорости рабочей подачи. Блок представляет собой список строк и ставится всегда в начало УП.

{\singlespacing
\begin{lstlisting}[
    language=python,showstringspaces=false,basicstyle=\ttfamily,frame=tb,
    caption={Преамбула}]
#преамбула
self.start_block = [
     '%', 'O01', 'G90', 'G21', 'G00X0Y0',
      'G00Z' + str(0), 
      'G00Z' + str(2),
      'G91', 'F300.0S6000M03'
      ]
\end{lstlisting}
}
{\bfseries Блоки тела УП.} Выделяется три блока тела управляющей программы: блок четных строк, блок нечетных строк и блок перемещений по оси Y. Блоки чередуются и образуют тело управляющей программы, в котором команды отвечают непосредственно за нанесение изображения. Все эти блоки состоят из команд линейной интерполяции с разными координатами. Блоки представляют собой списки списков, где внутренний список включает в себя два строковых литерала: пустой\,(куда производится подстановка координаты) и литерал с обозначением команды и оси. Так выглядят блоки для четных и нечетных строк:

{\singlespacing
\begin{lstlisting}[
    language=python,showstringspaces=false,basicstyle=\ttfamily,frame=tb,
    caption={Блоки тела управляющей программы}]
#блок для нечетных строк
self.body_block_unevenstr = [
     ['G01X-', ''], 
     ['G01Z-', ''],
     ['G01Z', '']
     ]
#блок для четных строк
self.body_block_evenstr = [
	  ['G01X', ''],
	  ['G01Z-', ''],
	  ['G01Z', '']
	  ]
\end{lstlisting}
}
Блок перемещения по оси Y состоит из одной команды G01 с параметром равным величине смещения.

{\bfseries Концевик.} Концевик является неизменяемым блоком, состоящим из трех команд и символа завершения программы. Команды входящие в блок: команда холостого хода в начало координат, остановка вращения шпинделя, команда конца программы. Вид концевика представлен ниже:

{\singlespacing
\begin{lstlisting}[
    language=python,showstringspaces=false,basicstyle=\ttfamily,frame=tb,
    caption={Блоки тела управляющей программы}]
#концевик
self.end_block = ['G00X0Y0', 'M05', 'M02', '%']
\end{lstlisting}
}

Во время инициализации входных параметров и блоков УП производится вычисление глубины врезания для всех точек изображения. Каждый элемент карты высот вычитается из величины нормирования, благодаря чему карта высот преобразуется в карту глубин. Затем, производится генерация тела программы из основных блоков посредством их чередования и подстановки параметров из карты глубин. Стоит отметить, что во время это процесса происходит оптимизация. Она заключается в том, что части изображения с белым фоном не обрабатываются, и инструмент смещается до ближайшего не белого участка. Это позволяет заметно уменишить количество G-кодов в УП и ускорить процесс обработки.

Результат работы модуля записывается в обыкновенный файл с расширением .txt (\autoref{app:txt}), который становится доступным для скачивания.