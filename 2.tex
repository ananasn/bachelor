 \def\figureautorefname{рис.}
  \def\equationautorefname{формуле}
\chapter{Модули реализуемого программного комплекса}
\section{Модуль 3D-моделирования рельефа}
\subsection{Назначение модуля}

Построение 3D-модели рельефа важно по двум причинам:
\begin{itemize}
\item 3D-модель рельефа позволяет визуализировать будущий результат.
\item 3D-модель является входными данными для множества CAM-систем.
\end{itemize}

Данный модуль реализует обе эти функции\,(\autoref{fig:seq_diagram}). 

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{seq_diagram.png}
    \caption[Функционирование модуля 3D-моделирования]
            {Функционирование модуля 3D-моделирования}
    \label{fig:seq_diagram}
\end{figure} 

После загрузки изображения и отправки его на сервер происходит обработка изображения, в результате которой 3D-модель записивается в~файл. Затем 3D-модель может быть отображена в браузере с помощью библиотеки Three.js \cite{Threejs_link}. Также приложение предоставляет возможность скачивания модели. Такая функциональность может оказаться полезной, например, когда пользователь хочет получить УП не в G-кодах, а в другой нотации (например, RML-код для оборудования фирмы Roland).
\subsection{Принципы построения модели}
После загрузки на сервер изображение подвергается обработке. В~гравировке вся цветовая информация преобразуется в рельеф с впадинами разной глубины. Для того, чтобы корректно перенести цветное изображение на изделие, его преобразуют в градации серого. Это производится с~помощью библиотеки Python Image Library \cite{Python_multimedia}, которая позволяет оперировать пикселями изображения. 

Цветное растровое изображение состоит из пикселей, каждый из \mbox{которых} характеризуется тремя величинами, определяющими содержание \mbox{красного}, синего и зеленого цветов. Известно, что оттенки серого \mbox{получаются} в~\mbox{результате} одинакового содержания этих цветов в пикселе. Таким образом, преобразование в градации серого осуществляется по \autoref{e:grey}:
\begin{equation}\label{e:grey}
  H = \frac{(R+G+B)}{3}, для  \forall p: \exists p = (R, G, B) 
\end{equation}
\begin{equation}\label{e:norm}
  R = \frac{H \times NORM}{256}
\end{equation}
Результирующая величина $H$ будет лежать в промежутке от 0 до 255, поэтому необходимо провести нормирование по \autoref{e:norm}, в результате которого величина переносится в промежуток от 0 до 3. Затем с шагами $\Delta x$ и $\Delta y$ генерируются вершины треугольных граней будущей модели рельефа. В результате работы модуля данные о модели записываются в~файл в~соответствии с форматом.
\subsection{Выбор формата}
 Существует множество форматов для хранения 3D-моделей, однако далеко не все из них пригодны для хранения рельефов и отображения их в веб-приложении.
 
 Можно определить два основных критерия, по которым стоит отбирать формат для разрабатываемого приложения:
 \begin{itemize}
 \item совместимость с библиотекой Three.js;
 \item размер файла модели.
 \end{itemize}
 
 Three.js поддерживает довольно широкий перечень традиционных форматов: STL ASCII,\footnote{STL ASCII (от англ. stereolithography) -- формат файла, используемый для хранения трехмерных моделей объектов, где список треугольных граней и нормалей хранится в обычном текстовом файле.} Binary STL,\footnote{Binary STL -- формат файла, используемый для хранения трехмерных моделей объектов, где список треугольных граней и нормалей хранится в бинарном виде.} VRML\footnote{VRML (англ. Virtual Reality Modeling Language) -- стандартизированный формат файлов для демонстрации трёхмерной интерактивной векторной графики.} и т.\,д.
 Также Three.js предлагает возможность хранения 3D-моделей в JSON\footnote{JSON (от англ. JavaScript Object Notation) — текстовый формат обмена данными, основанный на JavaScript.} формате. Изначально, был выбран формат JSON\,(\autoref{fig:json_view}), так как организация данных в нем наиболее проста и интуитивно понятна, а сам формат изначально предназначен для представления данных в веб-приложениях. Тем не менее после реализации стало очевидно,что для высокополигональных моделей рельефов такой формат не подходит. Основной проблемой оказался размер файла, который был слишком большим. А это в свою очередь сильно замедляло работу приложения.
 \begin{figure}[h!]
    \centering
    \includegraphics[width=.8\textwidth]{json.png}
    \caption[Представление модели в формате JSON]
            {Представление модели в формате JSON}
    \label{fig:json_view}
\end{figure} 

Самым оптимальным форматом оказался Binary STL\,(\autoref{fig:stl}), так как бинарный формат позволял максимально уменишить размер \mbox{3D-модели} рельефа.

 \begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{STL.png}
    \caption[Представление модели в формате Binary STL]
            {Представление модели в формате Binary STL}
    \label{fig:stl}
\end{figure} 
Сравнение JSON и Binary STL представлено на \,\autoref{fig:format_diagram}, диаграмма демонстрирует, насколько сокращается время загрузки модели при использовании Binary STL.
Диаграмма построена на основе данных, \mbox{полученных} при следующих характеристиках системы:
\begin{itemize}
\item  виртуальная машина Cloud9;
\item 512\,MБ ОЗУ;
\item жесткий диск объемом 1\,ГБ;
\item канал 10\,Мбит/c;
\item изображение 180$\times$256.
\end{itemize}
В результате применения формата STL Binary удается добиться сокращения размера файла более чем вполовину, а время загрузки модели сокращается в 6 раз.
 \begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{format_diagram.png}
    \caption[Сравнение JSON и Binary STL]
            {Сравнение JSON и Binary STL}
    \label{fig:format_diagram}
\end{figure} 
\section{Модуль редактирования изображений}
\subsection{Назначение модуля}
Очевидно, что  в некоторых случаях результат, визуализированный с помощью 3D-модели, может по определенным причинам не удовлетворить пользователя. И для того, чтобы получить подходящий результат, необходимо отредактировать входные данные, в качестве которых в разрабатываемом приложении выступает изображение.

Чаще всего причинами неудовлетворительного результата служат:
\begin{itemize}
\item низкое качество изображения;
\item слишком светлое изображение;
\item излишние детали изображения.
\end{itemize}
Все эти проблемы можно решить минимумом инструментов, а именно~--~настройками яркости и контрастности. Наиболее распространенная проблема для растровых изображений -- это низкое качество. Из-за <<пиксельности>> изображения по контурам могут возникаит деформации. Однако настройки контрастности и яркости позволяют избежать нежелательных деформаций\,(\autoref{fig:demonstration}).
 \begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{demonstration.png}
    \caption[Упразднение деформаций в моделях на основе растровых изображений]
            {Упразднение деформаций в моделях на основе растровых изображений}
    \label{fig:demonstration}
\end{figure} 
\subsection{Алгоритм изменения яркости}
Для регулировки яркости к каждому каналу каждого пикселя прибавляется определенное значение. Если оно положительное яркость увеличивается, если отрицательное яркость уменьшается\,(\autoref{fig:brightness}). 
\subsection{Алгоритм изменения контраста}
Для регулировки контраста вначале вычисляется средняя яркость изображения. Для этого вначале вычисляется яркость каждого \mbox{пикселя}. Затем для каждого пикселя находится отклонение от средней яркости. После чего это отклонение умножается на коэффициент контраста. \mbox{Полученная} величина прибавляется к значению каждого канала\,(\autoref{fig:contrast}).
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.73\textwidth]{Brightness.png}
    \caption[Алгоритм изменения яркости]
            {Алгоритм изменения яркости}
    \label{fig:brightness}
\end{figure} 
\begin{figure}[h!]
    \raggedleft
    \includegraphics[width=1\textwidth]{Contrast.png}
    \caption[Алгоритм изменения контраста]
            {Алгоритм изменения контраста}
    \label{fig:contrast}
\end{figure} 
\section{Модуль генерации управляющих программ}
\subsection{Назначение модуля}
Модуль генерации УП предназначен для \mbox{получения} последовательности G-кодов. G-код включает в себя команды управления перемещением инструмента и рабочих органов оборудования, команды определяющие режимы обработки, технологические команды, команды выбора системы координат и едениц измерений \cite{theory_of_cnc}. Большинство программного обеспечения, управляющего оборудованием, использует в качестве управляющих программ последовательности G-кодов. Стоит отметить, что сам G-код, определяемый стандартами ISO 6983-1:2009 \cite{chpu_iso} и ГОСТ 20999-83 \cite{chpu_gost}, может расширяться в зависимости от назначения и производителей оборудования. Фактически, G-код является некоторой основой для реального языка программирования устройств с ЧПУ. Однако использование \mbox{базовых} команд обеспечивает высокую вероятность корректной работы на~большинстве видов оборудования.

С точки зрения реализации, растровое изображение проще всего наносить точечно. Тем более, что при таком подходе понадобятся только стандартные G-коды. Таким образом, на основе данных, полученных на этапе обработки изображения и построения модели, генерируется управляющая программа, которая в дальнейшем становится доступной для скачивния с сервера.
\newpage
\subsection{Реализация модуля}
Генератор управляющих программ представляет собой модуль, кото\-рый хранится на сервере\,(\autoref{app:gcodes}). Внутри данного модуля реализован класс \verb|Generator|, инициализирующийся следующими значениями:
\begin{itemize}
\item карта высот, генерируемая на сервере при обработке изображения;
\item высота изображения в пикселях;
\item ширина изображения в пикселях;
\item величина смещения по осям;
\item величина нормирования;
\item хэш по имени изображения\,(рассчитывается по алгоритму Роберта Седжвика \cite{Azevedo199273} при загрузке на сервер).
\end{itemize}

Также при инициализации данного класса создаются основные блоки, из которых при генерации будет складываться УП:
\begin{itemize}
\item преамбула;
\item блоки тела УП;
\item концевик.
\end{itemize}

{\bfseries Преамбула.} Преамбула представляет собой неизменяемый блок. Она состоит из символа начала программы, имени программы, команд смены системы координат и единиц измерений, команды холостого \mbox{хода}, \mbox{команды} начала вращения шпинделя, команд установки скорости вращения шпинделя и скорости рабочей подачи. Блок преамбулы, представленный в \autoref{lst:preamb}, является списоком строк и ставится всегда в начало управляющей программы.

{\singlespacing
\begin{lstlisting}[
    language=python,showstringspaces=false,basicstyle=\ttfamily,frame=tb,
    caption={Преамбула},
    label={lst:preamb}]
# преамбула
self.start_block = [
     '%', 'O01', 'G90', 'G21', 'G00X0Y0',
     'G00Z' + str(0), 
     'G00Z' + str(2),
     'G91', 'M03', 'F300.0S6000'
]
\end{lstlisting}
}
{\bfseries Блоки тела УП.} Можно выделить три блока тела управляющей программы: блок четных строк, блок нечетных строк и блок перемещений по оси Y. Блоки чередуются и образуют тело управляющей программы, в котором команды отвечают непосредственно за нанесение изображения. Все эти блоки состоят из команд линейной интерполяции с разными \mbox{координатами}. Блоки представляют собой списки списков, где внутренний список включает в себя два строковых литерала: пустой\,(куда производится подстановка координаты) и литерал с обозначением команды и оси. Реализация блоков представлена в \autoref{lst:str_block}:

{\singlespacing
\begin{lstlisting}[
    language=python,showstringspaces=false,basicstyle=\ttfamily,frame=tb,
    caption={Блоки тела управляющей программы},
    label = {lst:str_block}]
# блок для нечетных строк
self.body_block_unevenstr = [
    ['G01X-', ''], 
    ['G01Z-', ''],
    ['G01Z', '']
]
# блок для четных строк
self.body_block_evenstr = [
    ['G01X', ''],
    ['G01Z-', ''],
    ['G01Z', '']
]
\end{lstlisting}
}
Блок перемещения по оси Y состоит из одной команды \verb|G01| с параметром равным величине смещения.

{\bfseries Концевик.} Концевик является неизменяемым блоком, состоящим из трех команд и символа завершения программы.  Команды входящие в~блок: команда холостого хода в начало координат, остановка вращения шпинделя, команда конца программы. Концевик представлен в \autoref{lst:end}:

{\singlespacing
\begin{lstlisting}[
    language=python,showstringspaces=false,basicstyle=\ttfamily,frame=tb,
    caption={Блоки тела управляющей программы},
    label = {lst:end}]
# концевик
self.end_block = ['G00X0Y0', 'M05', 'M02', '%']
\end{lstlisting}
}

В процессе инициализации входных параметров и блоков УП производится вычисление глубины врезания для всех точек изображения. Каждый элемент карты высот вычитается из величины нормирования, благодаря чему карта высот преобразуется в карту глубин. Затем производится генерация тела программы из основных блоков посредством их чередования и подстановки параметров из карты глубин. Стоит отметить, что во время генерации происходит оптимизация. Она заключается в том, что части изображения с белым фоном не обрабатываются, и инструмент смещается до ближайшего не белого участка. Это позволяет заметно уменишить количество G-кодов в УП и ускорить процесс обработки.

Результат работы модуля записывается в обыкновенный текстовый файл (\autoref{app:txt}), который становится доступным для скачивания.

Стоит отметить, что кроме вышеуказанного подхода, \mbox{использующего} линейную интерполяцию, существует подход использующий NURBS.\footnote{NURBS (англ. Non-uniform rational Bezier spline) -- математическая форма, применяемая в~компьютерной графике для генерации и представления кривых и поверхностей.} С~помощью NURBS можно описать поверхности любой сложной формы. Однако очевидно, что для того, чтобы перевести растровое изображение в~NURBS-геометрию потребуется трудоемкий процесс поиска контрольных узлов, касательных, весов и т.\,д. К тому же на данный момент синтаксис NURBS \cite{theory_of_cnc}  в нотации G-кодов недостаточно стандартизирован, а~многими станками не поддерживается вовсе.